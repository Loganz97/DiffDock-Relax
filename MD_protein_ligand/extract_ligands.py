"""
Adapted from original code from Pat Walters.
Split a protein-ligand complex into protein and ligands and assign ligand bond
orders using SMILES strings from Ligand Export.
"""

from io import StringIO
import os
import sys
from typing import Iterable
from warnings import warn

import pandas as pd
from prody import parsePDB, writePDB, writePDBStream
from rdkit import Chem
from rdkit.Chem import AllChem
import requests


LIGAND_EXPO_FILENAME = "Components-smiles-stereo-oe.smi"
LIGAND_EXPO_URL = f"http://ligand-expo.rcsb.org/dictionaries/{LIGAND_EXPO_FILENAME}"


def _read_ligand_expo():
    """
    Read Ligand Expo data, try to find a file called
    Components-smiles-stereo-oe.smi in the current directory.
    If you can't find the file, grab it from the RCSB (archived in gs://hx-brian 2023-06-11)
    :return: Ligand Expo as a dictionary with ligand id as the key
    """
    if not os.path.exists(LIGAND_EXPO_FILENAME):
        with open(LIGAND_EXPO_FILENAME, 'wb') as out:
            r = requests.get(LIGAND_EXPO_URL, allow_redirects=True)
            out.write(r.content)

    df = pd.read_csv(LIGAND_EXPO_FILENAME, sep="\t",
                     header=None,
                     names=["SMILES", "ID", "Name"])
    
    df.set_index("ID", inplace=True)

    return df.to_dict()


def _get_pdb_components(pdb_id):
    """
    Split a protein-ligand pdb into protein and ligand components
    :param pdb_id:
    :return:
    """
    pdb = parsePDB(pdb_id)
    protein = pdb.select('protein')
    ligand = pdb.select('not protein and not water')
    return protein, ligand


def _process_ligand(ligand, res_name, expo_dict,
                    chain=None):
    """
    Add bond orders to a pdb ligand
    1. Select the ligand component with name "res_name"
    2. Get the corresponding SMILES from the Ligand Expo dictionary
    3. Create a template molecule from the SMILES in step 2
    4. Write the PDB file to a stream
    5. Read the stream into an RDKit molecule
    6. Assign the bond orders from the template from step 3
    :param ligand: ligand as generated by prody
    :param res_name: residue name of ligand to extract
    :param expo_dict: dictionary with LigandExpo
    :return: molecule with bond orders assigned
    """

    if chain is None:
        warn("No chain suppled for extract_ligands, so defaulting to chain A. "
             "Not specifying a chain can result in multiple molecules combined into one SDF file! "
             "If ligand is not in chain A this will fail.")
        chain = "A"

    output = StringIO()
    sub_mol = ligand.select(f"resname {res_name} and chain {chain}")
    if sub_mol is None:
        warn(f"sub_mol is None for {res_name}")
        return None

    sub_smiles = expo_dict['SMILES'][res_name]

    template = AllChem.MolFromSmiles(sub_smiles)
    if template is None:
        print(f"template is None for {sub_smiles}. Returning None.", file=sys.stderr)
        return None

    writePDBStream(output, sub_mol)
    pdb_string = output.getvalue()

    rd_mol = AllChem.MolFromPDBBlock(pdb_string)

    new_mol = AllChem.AssignBondOrdersFromTemplate(template, rd_mol)

    return new_mol, sub_smiles


def _write_pdb(protein, pdb_name,
               output_pdb_name=None):
    """
    Write a prody protein to a pdb file
    :param protein: protein object from prody
    :param pdb_name: base name for the pdb file
    :return: None
    """
    output_pdb_name = output_pdb_name or f"{pdb_name}_protein.pdb"
    writePDB(f"{output_pdb_name}", protein)
    return output_pdb_name


def _write_sdf(new_mol, pdb_name:str, res_name:str,
               output_sdf_name:str|None=None) -> str:
    """
    Write an RDKit molecule to an SD file
    :param new_mol:
    :param pdb_name:
    :param res_name:
    :return:
    """
    output_sdf_name = output_sdf_name or f"{pdb_name}_{res_name}_ligand.sdf"
    writer = Chem.SDWriter(f"{output_sdf_name}")
    writer.write(new_mol)
    return output_sdf_name


def extract_ligands(pdb_name:str,
                    ligand_names:Iterable[str]|None=None,
                    chains:Iterable[str]|None=None,
                    output_pdb_name:str|None=None,
                    output_sdf_name:str|None=None) -> tuple[str, list[str], list[str]]:
    """
    Read Ligand Expo data, split pdb into protein and ligands,
    write protein pdb, write ligand sdf files
    :param pdb_name: id from the pdb, doesn't need to have an extension
    :return:
    """
    if chains is not None:
        assert ligand_names is not None, "chains requires ligand_names"
        assert len(chains) == len(ligand_names), "chains and ligand_names must be the same length"

    # ----------------------------
    # First write out protein part
    #
    df_dict = _read_ligand_expo()
    protein_sel, ligand_sel = _get_pdb_components(pdb_name)
    # write out the pdb with no ligands
    out_pdb_file = _write_pdb(protein_sel, pdb_name, output_pdb_name=output_pdb_name)

    # ----------------------------
    # Then write out ligands
    #
    res_name_list = list(set(ligand_sel.getResnames()))
    out_sdf_files = []
    out_sdf_smiles = []

    for res_name in res_name_list:
        if ligand_names is not None and res_name not in ligand_names:
            continue

        if chains is not None:
            chain = chains[ligand_names.index(res_name)]
        else:
            chain = None

        new_mol, new_mol_smiles = _process_ligand(ligand_sel, res_name, df_dict, chain)
        if new_mol is None:
            print(f"_process_ligand failed for {res_name}. Skipping")
            continue

        out_sdf_files.append(_write_sdf(new_mol, pdb_name, res_name, output_sdf_name=output_sdf_name))
        out_sdf_smiles.append(new_mol_smiles)

    return out_pdb_file, out_sdf_files, out_sdf_smiles


def extract_ligand(pdb_name:str, ligand_name:str,
                   chain=None,
                   output_pdb_name:str|None=None,
                   output_sdf_name:str|None=None) -> tuple[str, str, str]:
    """extract_ligands wrapper for a single ligand"""
    out_pdb_file, out_sdf_files, out_sdf_smiles = extract_ligands(pdb_name, [ligand_name], 
                                                                  [chain] if chain is not None else None, 
                                                                  output_pdb_name,
                                                                  output_sdf_name)
    return out_pdb_file, out_sdf_files[0], out_sdf_smiles[0]


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description='Extract ligands from a PDB file.')
    parser.add_argument('pdb_id', type=str, help='PDB ID')
    parser.add_argument('ligand_names', type=str, help='Comma-delimited list of ligand names')
    parser.add_argument('--chains', type=str, default=None, help='Comma-delimited list of chains for each ligand')
    
    args = parser.parse_args()
    args_ligand_names = args.ligand_names.split(",")
    args_chains = args.chains.split(",") if args.chains is not None else None

    outputs = extract_ligands(args.pdb_id, args_ligand_names, args_chains)
    print(outputs)
